// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Contributor:
// - Aaron Meihm ameihm@mozilla.com

// Generate scribe policy checks using data in the Ubuntu CVE tracker
// repository.
package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"regexp"
	"github.com/mozilla/scribe"
	"strings"
	"unicode"
)

type distPatchInfo map[string]string

type cveEntry struct {
	cveID  string
	pkgMap map[string]distPatchInfo
}

type releaseInformation struct {
	identifier string
	lsbmatch   string
	defid      string
}

var releaseList = []releaseInformation{
	{"utopic", "14.10", ""},
	{"vivid", "15.04", ""},
	{"trusty", "14.04", ""},
	{"precise", "12.04", ""},
	{"lucid", "10.04", ""},
}

var entries []cveEntry
var matchFilter *regexp.Regexp

// The hackTranslate* functions perform conversion on name and version
// strings if the package name is either "linux" or begins with "linux-". If
// this is the case, linux in the package name is translated to be
// "linux-image-generic". Additionally, the upload revision element if
// present in the version string is removed. This allows a comparison of
// the version to occur against a known package name (linux-image-generic),
// instead of requiring resolution of whatever the most recent installed
// kernel image package is which will be named linux-image-<ver>-generic.
func hackTranslateName(pkgname string) string {
	if pkgname != "linux" && !strings.HasPrefix(pkgname, "linux-") {
		return pkgname
	}
	return strings.Replace(pkgname, "linux", "linux-image-generic", 1)
}

func hackTranslateVersion(pkgname string, ver string) string {
	if !strings.HasPrefix(pkgname, "linux-image-generic") {
		return ver
	}

	ffunc := func(c rune) bool {
		if c == '-' {
			return true
		}
		return false
	}
	f := strings.FieldsFunc(ver, ffunc)
	if len(f) != 2 {
		return ver
	}
	ret := f[1]
	idx := strings.Index(ret, ".")
	if idx == -1 {
		return ver
	}
	idx2 := idx + 1
	for _, c := range ret[idx2:] {
		if !unicode.IsDigit(c) {
			break
		}
		idx2++
	}
	ret = f[0] + "." + ret[:idx] + ret[idx2:]

	return ret
}

func addReleaseDefinition(o *scribe.Document, rinfo *releaseInformation) {
	identifier := fmt.Sprintf("reldef-%v", rinfo.identifier)
	rinfo.defid = identifier

	obj := scribe.Object{}
	obj.Object = identifier + "-object"
	obj.FileContent.Path = "/etc"
	obj.FileContent.File = "^lsb-release$"
	obj.FileContent.Expression = "DISTRIB_RELEASE=(\\d{1,2}\\.\\d{1,2})"

	test := scribe.Test{}
	test.TestID = identifier + "-test"
	test.Object = obj.Object
	test.EMatch.Value = rinfo.lsbmatch

	o.Tests = append(o.Tests, test)
	o.Objects = append(o.Objects, obj)
}

func addReleaseDefinitions(o *scribe.Document) {
	for x := range releaseList {
		addReleaseDefinition(o, &releaseList[x])
	}
}

func getReleaseDefinition(dist string) string {
	for _, x := range releaseList {
		if dist == x.identifier {
			return x.defid
		}
	}
	return ""
}

func parseEntryFile(fpath string) (ret cveEntry) {
	const (
		_ = iota
		INNER_NONE
		INNER_PATCH
	)
	fd, err := os.Open(fpath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	defer func() {
		fd.Close()
	}()

	scanner := bufio.NewScanner(fd)
	parserMode := INNER_NONE
	curPkgName := ""
	ret.cveID = path.Base(fpath)
	ret.pkgMap = make(map[string]distPatchInfo)
	for scanner.Scan() {
		tokens := strings.Fields(scanner.Text())
		if len(tokens) == 0 {
			parserMode = INNER_NONE
			curPkgName = ""
			continue
		}

		if strings.HasPrefix(tokens[0], "Patches_") {
			parserMode = INNER_PATCH
			curPkgName = strings.TrimPrefix(tokens[0], "Patches_")
			curPkgName = strings.TrimRight(curPkgName, ":")
			curPkgName = hackTranslateName(curPkgName)
			ret.pkgMap[curPkgName] = make(map[string]string)
			continue
		}

		if parserMode == INNER_PATCH {
			if len(tokens) < 2 {
				continue
			}
			idx := strings.Index(tokens[0], "_")
			if idx == -1 {
				continue
			}
			distname := tokens[0][:idx]
			if tokens[1] == "released" && len(tokens) > 2 {
				patchver := tokens[2]
				patchver = strings.Trim(patchver, "()")
				patchver = hackTranslateVersion(curPkgName, patchver)
				ret.pkgMap[curPkgName][distname] = patchver
			}
		}
	}
	if err = scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	return
}

func loadEntries(dirpath string) {
	dirents, err := ioutil.ReadDir(dirpath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	for _, i := range dirents {
		if !strings.HasPrefix(i.Name(), "CVE-") {
			continue
		}
		if matchFilter != nil {
			if !matchFilter.MatchString(i.Name()) {
				continue
			}
		}
		fname := path.Join(dirpath, i.Name())
		entries = append(entries, parseEntryFile(fname))
	}
}

func addDefinition(o *scribe.Document, prefix string, pkgname string, dist string, cve cveEntry) {
	// Don't create a definition for anything that is not in our release
	// list.
	reldefid := getReleaseDefinition(dist)
	if reldefid == "" {
		return
	}

	// Create an object definition for the package
	objid := fmt.Sprintf("%v-object", prefix)
	obj := scribe.Object{}
	obj.Object = objid
	obj.Package.Name = pkgname

	// Create a test
	testid := fmt.Sprintf("%v-test", prefix)
	test := scribe.Test{}
	test.TestID = testid
	test.Object = obj.Object
	test.EVR.Value = cve.pkgMap[pkgname][dist]
	test.EVR.Operation = "<"
	disttestref := fmt.Sprintf("reldef-%v-test", dist)
	test.If = append(test.If, disttestref)

	o.Tests = append(o.Tests, test)
	o.Objects = append(o.Objects, obj)
}

func processEntries() {
	root := scribe.Document{}

	addReleaseDefinitions(&root)

	for i, ent := range entries {
		for x := range ent.pkgMap {
			for y := range ent.pkgMap[x] {
				prefix := fmt.Sprintf("ubuntu-%v-%v-%v", i, x, y)
				addDefinition(&root, prefix, x, y, ent)
			}
		}
	}

	buf, err := json.MarshalIndent(&root, "", "    ")
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
	fmt.Fprintf(os.Stdout, "%v\n", string(buf))
}

func main() {
	var fMatch string

	flag.StringVar(&fMatch, "i", "", "filter regexp")
	flag.Parse()
	args := flag.Args()
	if len(args) < 1 {
		fmt.Fprintf(os.Stderr, "specify path to ubuntu-cve-tracker directory\n")
		os.Exit(1)
	}

	fm, err := regexp.Compile(fMatch)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	matchFilter = fm

	entries = make([]cveEntry, 0)

	procdir := path.Join(args[0], "active")
	loadEntries(procdir)
	procdir = path.Join(args[0], "retired")
	loadEntries(procdir)
	processEntries()
}
